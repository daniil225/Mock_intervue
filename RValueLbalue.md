[Lecture 6. Rvalue references, part 1](https://www.youtube.com/watch?v=pjo8iZQWLMY&list=PL3BR09unfgcgJPQZKaacwzGmcXMtEA-19&index=12)

# Что такое lvalue и rvalue

Рассмотрим простой пример:

```c++
int x = 1; // Это попрождает имя для объекта в памяти. У него есть location
int &a = x; // lvalue связывается с location 
int&& b = 3*x; // 3*x - это значение и по сути это временный объект, у него нет своего location, и вот rvalue дает нам этот location. По сути этот механизм продливает время жизни временного объекта в памяти. 
const int& d = 3*x; // Это исключение для lvalue для того что бы давать location для временных объектов. 
```

Нельзя присваивать rvalue lvalue . Это нужно, что бы избежать проблем с выводом типов. 

Но инициализировать lvalue rvalue можно, так как по своей сути rvalue является lvalue

## Провисание ссылок

Провиснуть(dangle) могут все типы ссылок 

```c++
const int& clref(int p) { return p + 0; }// p + 0 is dead

int x = clref(1); // значене x не определено
int сx = clref(1); // значене сx не определено
```

![alt text](image.png)
![alt text](image-1.png)
![alt text](image-2.png)

## Refbinder

![alt text](image-3.png)

# На подумать 

![alt text](image-4.png)

По сути конструкторы по умолчанию это плохо потому что может возникнуть double delete 

![alt text](image-5.png)

# Проблемы с move

![alt text](image-6.png)

К сожалению современные компиляторы слишком умные, поэтому дописывают конструктор перемещения даже если его об этом не просили. Это может приводить к большим проблемам. 

Решение это следовать следующему правилу

![alt text](image-7.png)
![alt text](image-10.png)

# Краевой случай применимости 

![alt text](image-8.png)

# Правило объявления implicit методов

![alt text](image-9.png)

# Проблемы при попытке сделать эффективно и решение проблемы

![alt text](image-11.png)
![alt text](image-12.png)
![alt text](image-13.png)

# Свертка ссылок

![alt text](image-14.png)
![alt text](image-15.png)
![alt text](image-16.png)

# Когда использовать std::forward

![alt text](image-17.png)

По сути это perfect forwarding. И он передает идеально rvalue, если значение было таковым, и lvalue, если значение было таковым. 


# Рассмотрим move внутри

![alt text](image-18.png)

# А теперь forward 

![alt text](image-19.png)

Вся идея основанна на reference collapcing. И важно, что управляющий тип это шаблонный параметр, поэтому нам крайне важно указывать тип аргумента (управлящий аргумент) для std::forward. 

Рассмотрим странный пример работы, но он абсолютно легален, если учитывать работу std::froward 

![alt text](image-20.png)
![alt text](image-21.png)

![alt text](image-23.png)

# А может нащ perfect forwardind не особо то и perfect 

![alt text](image-24.png)

И тут мы видим, что perfect forwardind будет таковым с точностью до overloading set. И когда у нас есть стандартные преоьразования и пользовотельские преобразования, то наш механизм дает сбой. 

Вообще проблема с overloading set не решена. И если найдется решение, то это прям неплохо. 


# Категории значений

Это про то какие у нас вообще есть значения. 

Рассмотрим не тривиальную задачу. Довольно интересная:

![alt text](image-26.png)
![alt text](image-25.png)

Хитрое решение это использовать `std::declval`

![alt text](image-27.png)

мы всегда можем сконструировать rvalue даже, если у объекта нет конструктора. 

у всех lvalue можно найти имя и место, точнее имя связано с местом. 
а вот rvalue характеризуется перемещаемостью.  

![alt text](image-28.png)
![alt text](image-29.png)

![alt text](image-30.png)
![alt text](image-31.png)
![alt text](image-32.png)
![alt text](image-34.png)


# Когда мы пишем функцию возвращающую &&

![alt text](image-35.png)
![alt text](image-36.png)

Подобное аннатирование позволает понимать внутри класса над каким объектом класса мы сейчас работаем временным или тем у которого есть идентичность. 

Когда может пригодиться знание о том, с каким объектом работаем. И на самом деле ответ, с любым методом, который возвращает ссылку.

![alt text](image-37.png)

Очевидно, что нам было бы удобно получить compilation error

![alt text](image-38.png)


Пример, когда аннатация методов будет полезна

![alt text](image-39.png)

# Новые правила и улучшения 

![alt text](image-40.png)
![alt text](image-41.png)

# Принцип AAA - almost always auto

Этот принцип гласит - пишите для всех локальных переменных auto

![alt text](image-42.png)

И в С++17 это уже очень хорошо заработало. 

![alt text](image-43.png)

И попытались исправить идиому дополнив ее RR- ref ref

![alt text](image-44.png)

Здесь есть проблема с тем, что мы как бы закладываемся на интерфейс, но пишем а мне впринципе подойдет все что угодно. Это плохо. И это нас подводит к мысли о том, что нам хочется иметь возвращаемый тип, такой что бы он удовлетворял опеределенной цонцепции. И правило для С++20 можно переформулировать как AACRR (almost always concept ref ref)
