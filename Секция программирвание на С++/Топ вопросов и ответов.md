# Вопросы с Mock собеседования  

Ссылка на видео с собесовм: [Mock собеседование программистов](https://www.youtube.com/watch?v=xwb2FAKxCUo&list=PL_5NbJ27RRd3NK888hTFlpeyVlMWiT2LN&index=9)

## Вопрос про const с указателями
```c++

int value = 10;

const int* const_int_ptr = &value;          // const value
int const* int_const_ptr_1 = &value;       // const value 
int* const int_const_ptr_2 = &value;       // const address 
const int* const const_int_const = &value; // const value and address
```

## Вопросы про smart pointer

### std::shared_ptr

- Устройство и назначение?
- Механизм подсчета ссылок? Счетчик ссылок шарится между объектами. 
- Потокобезопасный ли? -  Нет shared_ptr не потокобезопасный. Счетик ссылок атомарный, но это не дает права ему называться потокобезопасным. 


### std::weak_ptr

- Какую проблему решают? Решает проблему циклических ссылок
- Что такое циклическая зависимость? - когда 2 объекта ссылаются друг на друга. Этот тип указателей решает эту проблему.  
- К чему приведут циклические зависимости? - Счетчик ссылок никогда не обнулится => память никогда не освободится. 


### std::unique_ptr
Какое присваивание разрешает? -move semantic - перемещающий конструктор и оператор перемещения. 

### std::auto_ptr 
Просто про проблемы и прочее. Почему от него отказались? 


## std::vector vs std::list

- Чем отличаются? std::vector - динамический массив. std::list - двунаправленный список 
- Что происходит при переполнение выделенного пространства в std::vector? Копируем все элементы в новый буфер увеличенного размера. Обычно увеличенный размер примерно в 2 раза больше. Нарипмер если было 10  то станет 20. Старый буфер удалается. Указатель указывает на новый буфер.  
- Как сделать так, что бы при перемещение объектов в std::vector было не копирование, а перемещение (была использована move semantic)? - У объектов нужно оператор перемещения и конструктор перемещения как noexcept. У вектора есть строгая гарантия безопасности при перемещении
- Асимптотическая сложность: 
    - Вставка в std::vector - если в конец то O(1) а амартизационная O(n)
    - Вставка в std::list - O(1)
    - Удаление в std::vector - O(n)
    - Удаление в std::list - O(1)
    - Поиск в std::vector:  
    - Поиск в std::list:  

## std::set vs std::unordered_set

- В чем разница? std::set - Дерево. Нужно если нужна сразу отсортированная структура. std::unordered_set - Реализована на Hash table. 
- Асимптотическая сложность? Поиск, Вставка,  Удаление в std::set - O(lg(n)) А для std::unordered_set - O(1) за исключением амартизационной сложности из за вызова рехеширования. 

##  Задачка на наследование и поведение методов помеченных ключевым словом virtual

```c++
struct Base
{
    Base() { print(); }

    void print() { std::cout << "Base" << std::endl; }

    virtual ~Base() { print(); }
};

struct Derived: Base
{
    Derived() { print(); }
    virtual void print() { std::cout << "Derived" << std::endl; }
    virtual ~Derived() { print(); }
};
int main()
{
    Base* base = new Derived();
    base->print();
    delete base;
}
```

- Что выведет программа? 
 
```
Base* base = new Derived(); =>
    Base constructor => "Base" Вызвался конструктор объекта базового класса 
    Derived constructor => "Derived" Вызвался конструктор объекта производного класса 
base->print(); =>
    "Base" => Так как в базовом классе метод void print() не помечен как virtual
delete base => Вызывается деструктор. Порядок вызова: Обратный порядку инициализации
    Так как деструктор помечен ключевым словом virtual вызовутся 2 разных деструктора
    "Derived" => Деструктор производного класса 
    "Base" => Деструктор базового класса 

Compiler output:
    Base
    Derived
    Base
    Derived
    Base
```

- Что произойдет если в базовом классе у деструктора убрать virtual?
В таком случае при удалении объекта не будет вызываться деструктор производного класса =>
Вывод программы будет такой:

```
Base
Derived
Base
Base
```

- А если метод print() поментить как virtual. Как изменится вывод? 

Теперь в строчке base->print() будет вызываться функция производного класса => "Base" заменится на "Derived" в строке вывода. 
Вывод программы:

```
Base
Derived
Derived
Derived
Base
```

- Какие есть тонкости вызова виртуальных функций из конструкторов и деструкторов? При вызове функий в конструкторах и деструкторах, к ним нужно относится так, будто у них нет ключевого слова virtual. Скотт Майерс пишет, что не нужно вызывать virtual функции из конструктора и деструктора. 

- Как работает виртуальность в C++? Есть таблицы виртуальных функиций. Они содержат указатели на свои методы в классе. 
- Сколько виртуальныз таблиц будет для кода выше? Будет 2 таблицы. По одной на каждый класс. 

- Изменится ли что-то, если убрать ключевое слово virtual в производном классе? Нет, так как в С++ достаточно в базовом классе объявить метод виртуальным, и это будет распространяться на все унаследованные классы. 
- Что изменится если в производном классе пометить метод как override? override проведет проверку, то ли мы перегружаем. Проверка типов принимаемых параметров и возвращаемых.


## Задачка с наследованием, и exception

```c++
struct Base
{
    Base() { print(); }

    void print() { std::cout << "Base" << std::endl; }

    virtual ~Base() { print(); }
};

struct Derived: Base
{
    Derived() { print(); throw "error";}
    virtual void print() { std::cout << "Derived" << std::endl; }
    virtual ~Derived() { print(); }
};
int main()
{
    try
    {
        Base* base = new Derived();
        base->print();
        delete base;
    } 
    catch(...)
    {

    }
}
```

Что выведет программа? 

```
Base* base = new Derived(); =>
    Base constructor => "Base" Вызвался конструктор объекта базового класса 
    Derived constructor => "Derived" Вызвался конструктор объекта производного класса 
    Дальше в конструкторе выбрасывается исключение => объект не сконстрирован => его деструктор не будет вызван.
    Вызовется лишь деструктор базового класса => "Base" из ~Base()

Compiler output:
    Base
    Derived
    Base
```

- Тонкости выбрасывания исключений из конструкторов? Если летит исключение из конструктора, то объект не явлается сконстрированным => его деструктор не будет вызван. 
- Тонкости выбрасывания исключений из деструкторов?  Все деструкторы неявно помечены ключевым словом noexcept. Если выбросить исключение из деструктора, то у программы вызовется std::terminate() и программа крашнется.

- Что такое double exception? Почему не стоит выбрасывать исключения из деструктора?
- Гарантии безопасности исключений? 

## Статический полиморфизм

- Что такое CRTP? 


## Вопросы по многопоточке

- Правило работы с std::mutex?
- Какие еще есть виды mutex? timed_mutex, shared_mutex. 
- Какие еще есть примитивы синхронизации? 
- Что такое spin lock? 
- Что такое dead lock? Из-за чего возникает? 
- Можно ли на одном std::mutex попать в dead lock? Ну типо рекурсивно, но это уже UB
- Какие есть виды lock_quard? 
- Что такое data race? 

## Что такое SSO / SBO? Smale string optimization and Smale buffer optimization  

## Написать примитивную реализацию std::shared_ptr

Задание:
- Реализовать дефорлтный конструктор, конструктор с указателем и конструктор копирования
- Конструктор копирования, оператор копирования
- реализовать деструктор
- реализовать примитивный вариант make_shared

