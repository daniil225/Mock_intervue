Разберем некоторые вопросы связанные с шаблонным програмированием на С++. Этот гайд краткая выжымка по 3-м лекциям от Константина Владимирова с его курса MIPT на Русском языке. 


# Общие вопросы 

## ODR

ODR - one defenition rule. 
Итак важно отметить, что **объявление** идет раньше **определения**. 
Все определения - это объявления

У каждой сущности в С++ есть declaration, когда определается ее тип и (опционально) defenition, когда определеается ее положение в памяти. 

ODR гласит:Сколько угодно declarations, но не более чем один defenition

Нужно обратить внимание на слово одна defenition
    - Для переменных и функций одна означает одна на всю программу
    - Для Классов и шаблонных функций одна означает на еденицу трансляции (one defenition per unit translation)  

Собственно по этой причине нельзя выносить тела функций в header, а вот определения классов можно и никаких проблем не будет. 

Для header static inline functions это классика, которая ограничивает область видимости. Тогда в header может быть определение функций. 


## Разрешение перегрузки в классах 

Рассмотрим пример

```c++
class Bar
{
    int foo(int);
    public:
    int foo(char);
};

Bar b;
b.foo(1); // Что будет? Вызов public метода или ошибка компиляции? 
```
По стандарту сейчас будет ошибка, так как контроль доступа идет после разрешения перегрузки. 

## Как писать бинарные операторы для классов 

Главное правило: Любой бинарный оператор заводится вне класса
Например для оператора `operator==` для `basic_string` может выглядеть вот так:

```c++
template<typename CharT, typename Traits, typename Alloc>
bool operator==(const basic_string<CharT, Traits, Alloc>& lhs,
                const basic_string<CharT, Traits, Alloc>& rhs)
                {
                    return lhs.compare(rhs) == 0;
                }
```

Этот ариант решения плох тем, что мы каждый раз будем платить за копирование при сравнении
строк вида: `"Hello" == str`
Поэтому нужно дополнить реализацию еще 2-мя функциями:

```c++
template<typename CharT, typename Traits, typename Alloc>
bool operator==(const CharT* lhs,
                const basic_string<CharT, Traits, Alloc>& rhs)
                {
                    return rhs.compare(lhs) == 0;
                }

template<typename CharT, typename Traits, typename Alloc>
bool operator==(const basic_string<CharT, Traits, Alloc>& lhs,
                const CharT* rhs)
                {
                    return lhs.compare(rhs) == 0;
                }
```

## Проблема конфликта имен

Начнем с описания проблемы, у нас есть `operator<<`, который может может находиться в лбом пространстве имен

Допустим мы пишем `std::cout << "Hello\n";` Это вполне может быть эквивалентно следующему: `operator<<(std::cout, "Hello\n");` И для того, что бы это работало, у нас оператор должен быть из пространства имен `std`: `std::operator<<(std::cout, "Hello\n");`, но компиятор не может об этом узнать из записи: `std::a << b;`

Решением явлается Поиск Кенинга, которое заключается в следующем:

1. Компилятор ищет имя функции из текущего и всех охватывающих пространств имен
2. Если оно не найдено, компиялото ищет имя в пространствах имен ее аргументов

```c++
namespace N { struct A; int f(A*); }
int g(N::A *a) { int i = f(a); return i; }
```

Однако у нас остались проблемы:

```c++
typedef int f;
namespace N { struct A; int f(A*); }
int g(N::A *a) { int i = f(a); return i; }
```
В таком случае будет либо не определенное поведение, либо ошибка компиляции, если не будет противоречий

### Поиск Керирга и Шаблоны

Следующий пример не работает:

```c++
namespace N 
{
    struct A;
    template<typename T> int f(A*);
}

int g(N::A *a)
{
    int i = f<int>(a);
    return i;
}
```

Причиной явлается следующиее: старнности синтаксического анализа С++. Имя f не введено как имя шаблонной функции, поэтому компилятор предполагает, что это переменная, а треугольная скобка - сравнение на меньше. 

Тем не менее можно заставить работать этот код:

```c++
namespace N 
{
    struct A;
    template<typename T> int f(A*);
}

template<typename T> void f(int); // неважно какой параметр 

int g(N::A *a)
{
    int i = f<int>(a); // теперь все Ok
    return i;
}
```

# Шаблоны функций

## Порождение фукнции

Рассмотрим простой пример:
```c++
template<typename T> do_nth_power(T x, T acc, unsigned n) {...}

// Здесь объявится прототип 
unsigned do_nth_power(unsigned x, unsigned acc, unsigned n);

unsigned nth_power(unsigned x, unsigned n)
{
    ...
    return do_nth_power<unsigned>(x, 1u, n);
}

// Здесь уже будет реализация
unsigned do_nth_power(unsigned x, unsigned acc, unsigned n){}
```

>Для зависимых шаблонных функций все будет аналогично


## Манглирование

Манглирование - это такая технология генерации имен функций (меток) в асеемблерном коде
По сути это ответ на вопрос почему в С нет шаблонов. Все потому что шаблоны требуют манглирования имен. А вот язык С дает горазддо более строгие гарантии по именам (для С++ они доступны с подификатором `extern "C"`, но шаблоны с ним не доступны). 


## Предварительное объявление

Поскольку экземпляр шаблонной фукнции это просто функция, она может быть предварительно объявлена. 

```c++
template<typename T> do_nth_power(T x, T acc, unsigned n);
...

template<typename T> do_nth_power(T x, T acc, unsigned n)
{
    ...
}
```

##  Многомодульные программы

Для многомодульных программ предобяъфвления будут работать плохо. 

```c++

//header.h
template<typename T> do_nth_power(T x, T acc, unsigned n);

// module1.cc
unsigned nth_power(unsigned x, unsigned n)
{
    ...
    return do_nth_power<unsigned>(x, 1u, n); // требует видимого тела шаблона 
}

// module2.cc
unsigned nth_power(int x, unsigned n)
{
    ...
    return do_nth_power<int>(x, 1u, n); // требует видимого тела шаблона 
}
```

## Вывод типов до подстановки 

Для параметров явлающимися типами, работает вывод типов
```c++
int x = max(1, 2); // int max<int> (int, int);
```

При выводе режутся ссылки и **внешние** cv-квалификаторы
```c++
const int& a = 1;
const int& b = 2;
int x = max(a,b); // int max<int>(int, int);
```

Вывод не работает, если он не однозначен

```c++
unsigned x = 5; do_nth_power(x, 2, n); // FAIL
int a = 1; float b = 1.0; max(a,b); // FAIL
```

>Зачем сделали, так, что cv-квалификаторы режутся
Для того, что бы не плодить инстанцирования

## Вывод уточненных типов

Иногда шаблонный тип аргумента может быть уточнен ссылкой или указателем и cv-квалификатором 

```c++
template<typename T> T max(const T& x, const T& y);
```

В этом случае выведенный тип тоже будет уточнен

```c++
int a = max(1, 3); // int max<int>(const int& x, const int& y);
```

Уточненный вывод иначе работает с типами: он сохранает cv-квалификаторы

```c++
template<typename T> void foo(T& x);

const int& a = 3;
int b = foo(a); // -> void foo<const int>(const int& x);
```
Вывод типов работает гораздо шире, чем обычно все помнят:

```c++
template<typename T> int foo(T(*p)(T));
int bar(int);

foo(bar); // int foo<int>(int(*p)(int)); 

```

Могут быть выведены параметры явлающиеся константными

```c++

template<typename T, int N> void buz(T const(&)[N]);
buz({1,2,3}); // -> void buz<int, 3>(int const(&)[3]);
```

## Частичный вывод типов

Возвращаемое значение из функции не создает контекст вывода

```c++
template<typename DstT, typename SrcT>
inline Dst implicit_cast(SrcT const& x){return x};

double value = implicit_cast(-1); // FAIL
```

Но при этом возможен частичный вывод

```c++
double value = implicit_cast<double, int>(-1); // ok
double value = implicit_cast<double>(-1); // ok
```

Отметим, что парметры по умолчанию не используются для вывода типов шаблонного паметра

```c++
template<typename T> void foo(T x = 1.0);
foo(1); // ok
foo(); // FAIL

// Исправления 
template<typename T = double> void foo(T x = 1.0);
foo(1); // ok
foo(); // ok 
```
Парметр по умолчанию для шаблона подсказал, что нужно делать компилятору


# Перегрузка функций

Одно и то же имя может соответствовать многим сигнатуроам

```c++
float sqrt(float x); // 1
double sqrt(double x);// 2
long double sqrt(long double sqrt); // 3

sqrt(1.0f)// 1
sqrt(1.0) // 2

sqrt(1); // Перегрузка может создавать неоднозначности
```

## Ограничения перегрузки

Функция не может быть перегружена по cv-квалификатору

```c++
void foo(int);
void foo(const int); // FAIL

void bar(char*);
void bat(char * const); // FAIL
```

Однако это не относится к cv-квалификаторам внешнего типа

```c++
void foo(int&);
void foo(const int&); // OK

void foo(char*);
void foo(const char*); // OK
```

# Разрешение перегрузки 

Для разрешения перегрузки есть набор простых мнемонических правил:

## Три правила для обычных функций

- Идеальное совпадение выигрывает
- Все стандартные преобразования равны
- Троеточия проигрывают почти всему

### Идеальное совпадение выигрывает

Для любых функций, если в множестве перегрузок, есть идеальное совпадение

```c++
void foo(int x); // 1
void foo(short x); // 2
foo(1); // -> 1
```

При этом идеальное совпадение-это еще и ссылка правильного типа

```c++
void foo(const int& x); // 1
void foo(short x); // 2
foo(1); // 1
```

В том числе и обычная левая ссылка может быть идеальным совпадением

```c++
void foo(int& x); // 1
void foo(const int& x); // 2
foo(1); // 2
int y; foo(y); // 1
```

Два идеальных совпадения это конфликт

```c++
void foo(const int& x); // 1 
void foo(int x); // 2
foo(1); // FAIL
```

### Все стандартные преобразования равны

Все стандатные преобразования одноранговые

```c++
void foo(char x); // 1
void foo(long x); // 2
foo(1); // FAIL
```

Люыбые стандартные преобразования выигрывают у пользовотельских

```c++
struct MyClass { MyClass(int x) {} };

void foo(char x); // 1
void foo(MyClass x); // 2

foo(1); // 1
```

### Троеточия проигрывают почти всему

Троеточия проигрывают и стандартным и пользовотельским преобразованиям

```c++
void foo(char x); // 1
void foo(long x); // 2
void foo(MyClass x); // 3
void foo(...); // 4

foo(1); // Сначала 1,2,3 и уже потом 4
```

Они выигрывают только у неправильных ссылок

```c++
void foo(...); // 1
void foo(int& x); // 2

foo(1); // 1
```


## Три правила для шаблонных фукнци

- Точно подходящая фукнция выигрывает у шаблонов
- Более специальный шаблон выигрывает у менее специального 
- Меньшее количество аргруменом выигрывает против большего


### Точно подходящая фукнция выигрывает у шаблонов

Это так, даже если шаблон подходит точно

```c++
int foo(int a); // 1
<typename T> T foo(T a); // 2

foo(1); // 1
```

Но можно явно указать, что мы хотим шаблон

```c++
foo<>(1); // 2
foo<int>(1); // 2
```

При этом стандартное преобразование проиграывает шаблону

```c++
foo(1.0); // 2
```

Нужно быть осторожным при применении перегрузки и обычных функций

```c++
template<typename T>
const T& min(const T& a, const T& b) { return a < b ? a : b; }

double min(double a, double b) { return a < b ? a : b; }

template<typename T>
const T& min(const T& a, const T& b, const T& c) { return min(min(a,b),c); }
```

НУ будет segmentation fault ))) Но как он тут возник????
Здесь же даже нет разыменования указателей 
Тааак здесь проблема следующая

1. Когда мы вызываем min(a,b,c), то очевидно используется 
Шаблонная перегрузка с 3-я параметрами. 
2. Далее для const& T double - это идеальный кандидат для вызова, и вызывается min(double, double), которая возвращает ссылку на локальный объект, по значению, который живет до конца локального контекста, то есть до точки с зяпятой
3. Далее мы вызываем min с 2 параметрами и вызывается уже первая функция. И после этого возвращается ссылка на локальный объект, который инвалидируется, добро пожаловать в segmentation fault 


### Более специальный шаблон выигрывает у менее специального

```c++
template<typename T> void f(T); // 1
template<typename T> void f(T*); // 2
template<typename T> void f(T**); // 3
template<typename T> void f(T***); // 4
template<typename T> void f(T****); // 5

int ***a;
f(a); // 4
f<int**>(a); // 2
```

### Меньшее количество аргруменом выигрывает против большего

Меньшее количество выигрывает у большего, за исключением тех случаев, когда это противоречит правилу 2 

```c++
template<typename T1, typename T2> void f(T1, T2); // 1
template<typename T> void f(T, T*); // 2

double t, s;
f(t, &s); // 2
```

Но при конфликте с предыдущим правилом это не работает

```c++
template<typename T> void g(T, T); // 1
template<typename T1, typename T2> g(T1, T2*); // 2
template<typename T1, typename T2> g(T1*, T2*); // 3

g(&t, &s); // FAIL
```

# Шаблоны классов