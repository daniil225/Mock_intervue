Разберем некоторые вопросы связанные с шаблонным програмированием на С++. Этот гайд краткая выжымка по 3-м лекциям от Константина Владимирова с его курса MIPT на Русском языке. 


# Общие вопросы 

## ODR

ODR - one defenition rule. 
Итак важно отметить, что **объявление** идет раньше **определения**. 
Все определения - это объявления

У каждой сущности в С++ есть declaration, когда определается ее тип и (опционально) defenition, когда определеается ее положение в памяти. 

ODR гласит:Сколько угодно declarations, но не более чем один defenition

Нужно обратить внимание на слово одна defenition
    - Для переменных и функций одна означает одна на всю программу
    - Для Классов и шаблонных функций одна означает на еденицу трансляции (one defenition per unit translation)  

Собственно по этой причине нельзя выносить тела функций в header, а вот определения классов можно и никаких проблем не будет. 

Для header static inline functions это классика, которая ограничивает область видимости. Тогда в header может быть определение функций. 


# Шаблоны функций

## Порождение фукнции

Рассмотрим простой пример:
```c++
template<typename T> do_nth_power(T x, T acc, unsigned n) {...}

// Здесь объявится прототип 
unsigned do_nth_power(unsigned x, unsigned acc, unsigned n);

unsigned nth_power(unsigned x, unsigned n)
{
    ...
    return do_nth_power<unsigned>(x, 1u, n);
}

// Здесь уже будет реализация
unsigned do_nth_power(unsigned x, unsigned acc, unsigned n){}
```

>Для зависимых шаблонных функций все будет аналогично


## Манглирование

Манглирование - это такая технология генерации имен функций (меток) в асеемблерном коде
По сути это ответ на вопрос почему в С нет шаблонов. Все потому что шаблоны требуют манглирования имен. А вот язык С дает горазддо более строгие гарантии по именам (для С++ они доступны с подификатором `extern "C"`, но шаблоны с ним не доступны). 


## Предварительное объявление

Поскольку экземпляр шаблонной фукнции это просто функция, она может быть предварительно объявлена. 

```c++
template<typename T> do_nth_power(T x, T acc, unsigned n);
...

template<typename T> do_nth_power(T x, T acc, unsigned n)
{
    ...
}
```

##  Многомодульные программы

Для многомодульных программ предобяъфвления будут работать плохо. 

```c++

//header.h
template<typename T> do_nth_power(T x, T acc, unsigned n);

// module1.cc
unsigned nth_power(unsigned x, unsigned n)
{
    ...
    return do_nth_power<unsigned>(x, 1u, n); // требует видимого тела шаблона 
}

// module2.cc
unsigned nth_power(int x, unsigned n)
{
    ...
    return do_nth_power<int>(x, 1u, n); // требует видимого тела шаблона 
}
```

## Вывод типов до подстановки 

Для параметров явлающимися типами, работает вывод типов
```c++
int x = max(1, 2); // int max<int> (int, int);
```

При выводе режутся ссылки и **внешние** cv-квалификаторы
```c++
const int& a = 1;
const int& b = 2;
int x = max(a,b); // int max<int>(int, int);
```

Вывод не работает, если он не однозначен

```c++
unsigned x = 5; do_nth_power(x, 2, n); // FAIL
int a = 1; float b = 1.0; max(a,b); // FAIL
```

>Зачем сделали, так, что cv-квалификаторы режутся
Для того, что бы не плодить инстанцирования

## Вывод уточненных типов

Иногда шаблонный тип аргумента может быть уточнен ссылкой или указателем и cv-квалификатором 

```c++
template<typename T> T max(const T& x, const T& y);
```

В этом случае выведенный тип тоже будет уточнен

```c++
int a = max(1, 3); // int max<int>(const int& x, const int& y);
```

Уточненный вывод иначе работает с типами: он сохранает cv-квалификаторы

```c++
template<typename T> void foo(T& x);

const int& a = 3;
int b = foo(a); // -> void foo<const int>(const int& x);
```
Вывод типов работает гораздо шире, чем обычно все помнят:

```c++
template<typename T> int foo(T(*p)(T));
int bar(int);

foo(bar); // int foo<int>(int(*p)(int)); 

```

Могут быть выведены параметры явлающиеся константными

```c++

template<typename T, int N> void buz(T const(&)[N]);
buz({1,2,3}); // -> void buz<int, 3>(int const(&)[3]);
```

## Частичный вывод типов

Возвращаемое значение из функции не создает контекст вывода

```c++
template<typename DstT, typename SrcT>
inline Dst implicit_cast(SrcT const& x){return x};

double value = implicit_cast(-1); // FAIL
```

Но при этом возможен частичный вывод

```c++
double value = implicit_cast<double, int>(-1); // ok
double value = implicit_cast<double>(-1); // ok
```

Отметим, что парметры по умолчанию не используются для вывода типов шаблонного паметра

```c++
template<typename T> void foo(T x = 1.0);
foo(1); // ok
foo(); // FAIL

// Исправления 
template<typename T = double> void foo(T x = 1.0);
foo(1); // ok
foo(); // ok 
```
Парметр по умолчанию для шаблона подсказал, что нужно делать компилятору


# Перегрузка функций

Одно и то же имя может соответствовать многим сигнатуроам

```c++
float sqrt(float x); // 1
double sqrt(double x);// 2
long double sqrt(long double sqrt); // 3

sqrt(1.0f)// 1
sqrt(1.0) // 2

sqrt(1); // Перегрузка может создавать неоднозначности
```

## Ограничения перегрузки

Функция не может быть перегружена по cv-квалификатору

```c++
void foo(int);
void foo(const int); // FAIL

void bar(char*);
void bat(char * const); // FAIL
```

Однако это не относится к cv-квалификаторам внешнего типа

```c++
void foo(int&);
void foo(const int&); // OK

void foo(char*);
void foo(const char*); // OK
```

# Разрешение перегрузки 

Для разрешения перегрузки есть набор простых мнемонических правил:

## Три правила для обычных функций

- Идеальное совпадение выигрывает
- Все стандартные преобразования равны
- Троеточия проигрывают почти всему

### Идеальное совпадение выигрывает

### Все стандартные преобразования равны

### Троеточия проигрывают почти всему

## Три правила для шаблонных фукнци

- Точно подходящая фукнция выигрывает у шаблонов
- Более специальный шаблон выигрывает у менее специального 
- Меньшее количество аргруменом выигрывает против большего


# Шаблоны классов