[5 Лекция. Вывод типов](https://www.youtube.com/watch?v=tTBwW6f3J3Q&list=PL3BR09unfgcgJPQZKaacwzGmcXMtEA-19&index=7)

Ручной и автоматический вывод, новый синтаксис функций, хинты для вывода типов конструкторами

Рассматривается вывод шаблонами функций, конструкторами классов, написание собственных хинтов, механизмы decltype и auto

# Вывод типов шаблонами

1. Вывод не уточненных типов. Ссылки и cv(const volatile)-квалификаторы игнорируются для T
2. Вывод уточненных типов. Уточнающая обвязка игнорируется для T, но cv-квалификаторы сохраняюттся. Типичные уточнители это ссылки и указатели. 

Давайте подробно разберём этот код на C++ и объясним, почему вывод типов для шаблонов `foo` и `bar` работает именно так, как показано в изображении. Мы пошагово разберём каждую строку, чтобы понять, как компилятор выводит типы.



## Код из изображения:

```cpp
template <typename T> void foo(T t);
template <typename T> void bar(T& t);

int x = 42;
int const &y = x;
int const * const z = &x;

foo(x); // -> foo<int>(int)
foo(y); // -> foo<int>(int)
foo(z); // -> foo<int const *>(int const *)

bar(x); // -> bar<int>(int&)
bar(y); // -> bar<int const>(int const &)
bar(z); // -> bar<int const * const>(int const * const &)
```

---

### 1. Объяснение шаблонов `foo` и `bar`

#### Шаблон `foo`:
```cpp
template <typename T> void foo(T t);
```
- Здесь параметр `t` передаётся **по значению**.
- Это означает, что `T t` создаёт копию аргумента, который передаётся в функцию.
- При передаче по значению квалификаторы `const` и `volatile` для типа `T` **игнорируются** (они снимаются), потому что копия аргумента становится локальной переменной внутри функции, и её можно изменять независимо от исходного объекта.
- Однако указатели или ссылки (например, `int*`, `int&`) остаются частью типа `T`, так как они являются частью сигнатуры типа.

#### Шаблон `bar`:
```cpp
template <typename T> void bar(T& t);
```
- Здесь параметр `t` передаётся **по ссылке**.
- Это означает, что `T& t` привязывается к исходному объекту (аргументу), и `T` выводится как тип самого объекта, включая все квалификаторы (`const`, `volatile` и т.д.).
- Поскольку передача идёт по ссылке, `T` будет точно соответствовать типу аргумента (за исключением того, что ссылка `&` добавляется автоматически к аргументу, но она не включается в сам `T`).

---

### 2. Переменные `x`, `y`, `z`

Давайте разберём типы переменных, чтобы понять, что именно передаётся в функции:

- **`int x = 42;`**
  - `x` — это обычная переменная типа `int`.
  - Её можно изменять, так как она не `const`.

- **`int const &y = x;`**
  - `y` — это **константная ссылка** на `int`.
  - Это означает, что `y` привязывается к `x`, но через `y` нельзя изменить значение `x` (из-за `const`).
  - Тип `y` — `int const &`, но при передаче `y` в функцию учитывается **базовый тип** (то, на что ссылается `y`), то есть `int const`.

- **`int const * const z = &x;`**
  - `z` — это **константный указатель на константный `int`**.
  - Разберём:
    - `int const *` — указатель на `const int` (нельзя изменить значение, на которое указывает `z`).
    - `const z` — сам указатель `z` тоже `const` (нельзя изменить адрес, на который указывает `z`).
  - Тип `z` — `int const * const`.

---

### 3. Вызовы `foo` и вывод типов

#### `foo(x); // -> foo<int>(int)`
- `x` имеет тип `int`.
- В `foo` аргумент передаётся **по значению**, поэтому `T t` означает, что `T` должен быть таким, чтобы `T t` соответствовало типу `x`.
- Поскольку `x` — это `int`, компилятор выводит `T = int`.
- Итог: `foo<int>(int)` — функция принимает `int` по значению.

#### `foo(y); // -> foo<int>(int)`
- `y` имеет тип `int const &` (константная ссылка на `int`).
- Поскольку `foo` принимает аргумент **по значению**, компилятор "разворачивает" ссылку:
  - Ссылка (`&`) снимается, так как передача по значению создаёт копию.
  - Квалификатор `const` также снимается, потому что при передаче по значению `const` не имеет значения (копия аргумента внутри функции не связана с исходным объектом).
- Базовый тип `y` — это `int const`, но после снятия `const` (из-за передачи по значению) остаётся `int`.
- Поэтому `T` выводится как `int`.
- Итог: `foo<int>(int)` — функция принимает `int` по значению.

#### `foo(z); // -> foo<int const *>(int const *)`
- `z` имеет тип `int const * const` (константный указатель на константный `int`).
- Поскольку `foo` принимает аргумент **по значению**, создаётся копия `z`.
- Квалификатор `const`, который относится к самому указателю (`int const * const`), **снимается**, так как копия указателя внутри функции не обязана быть `const` (это просто локальная переменная типа указатель).
- Однако `const`, который относится к данным, на которые указывает указатель (`int const *`), остаётся, потому что это часть типа указателя.
- Таким образом, тип `z` после снятия "внешнего" `const` становится `int const *`.
- Поэтому `T` выводится как `int const *`.
- Итог: `foo<int const *>(int const *)` — функция принимает указатель `int const *` по значению.

---

### 4. Вызовы `bar` и вывод типов

#### `bar(x); // -> bar<int>(int&)`
- `x` имеет тип `int`.
- В `bar` аргумент передаётся **по ссылке**, поэтому `T& t` означает, что `T&` должно соответствовать типу `x`.
- Тип `x` — `int`, и он передаётся как `int&` (ссылка добавляется автоматически, так как `bar` принимает по ссылке).
- Компилятор выводит `T` так, чтобы `T&` было `int&`. Следовательно, `T = int`.
- Итог: `bar<int>(int&)` — функция принимает `int` по ссылке.

#### `bar(y); // -> bar<int const>(int const &)`
- `y` имеет тип `int const &` (константная ссылка на `int`).
- В `bar` аргумент передаётся **по ссылке**, поэтому `T& t` привязывается к `y`.
- Тип `y` — это `int const &`. Компилятор смотрит на тип, к которому привязывается ссылка:
  - Сам `y` уже является ссылкой, поэтому передача `y` в `bar` означает, что `T&` должно соответствовать типу `int const &`.
- Чтобы `T&` было `int const &`, `T` должно быть `int const`.
- Итог: `bar<int const>(int const &)` — функция принимает `int const` по ссылке.

#### `bar(z); // -> bar<int const * const>(int const * const &)`
- `z` имеет тип `int const * const` (константный указатель на константный `int`).
- В `bar` аргумент передаётся **по ссылке**, поэтому `T& t` привязывается к `z`.
- Тип `z` — это `int const * const`. Компилятор определяет `T` так, чтобы `T&` соответствовало `int const * const &`.
- Чтобы `T&` было `int const * const &`, `T` должно быть `int const * const`.
- Итог: `bar<int const * const>(int const * const &)` — функция принимает `int const * const` по ссылке.

---

### 5. Почему так происходит?

#### Разница между `foo` и `bar`:
- **`foo` передаёт по значению**:
  - При передаче по значению создаётся копия аргумента.
  - Квалификаторы `const` и ссылки (`&`) снимаются для верхнего уровня типа (но не для вложенных типов, например, в указателях).
  - Поэтому `T` в `foo` всегда "упрощает" тип до базового (например, `int const` → `int`, но `int const *` остаётся `int const *`).

- **`bar` передаёт по ссылке**:
  - При передаче по ссылке `T&` привязывается к исходному объекту, и `T` выводится с учётом всех квалификаторов (`const`, указатели, ссылки и т.д.).
  - Поэтому `T` в `bar` точно отражает тип аргумента, включая все `const`.

#### Ключевое правило вывода типов:
- Для **передачи по значению** (`foo`): снимаются верхние квалификаторы `const` и ссылки.
- Для **передачи по ссылке** (`bar`): `T` выводится так, чтобы `T&` точно соответствовало типу аргумента.

---

### 6. Итоговое объяснение:

#### Для `foo`:
- `foo(x)`: `x` — `int`, значит `T = int`.
- `foo(y)`: `y` — `int const &`, но при передаче по значению `const` и `&` снимаются, значит `T = int`.
- `foo(z)`: `z` — `int const * const`, при передаче по значению снимается только "внешний" `const` (для указателя), остаётся `int const *`, значит `T = int const *`.

#### Для `bar`:
- `bar(x)`: `x` — `int`, `T&` = `int&`, значит `T = int`.
- `bar(y)`: `y` — `int const &`, `T&` = `int const &`, значит `T = int const`.
- `bar(z)`: `z` — `int const * const`, `T&` = `int const * const &`, значит `T = int const * const`.

---

Внешний CV-квалификатор в контексте C++ — это квалификатор `const` или `volatile` (отсюда "CV" — const/volatile), который применяется к **верхнему уровню типа** переменной или объекта. Давайте разберём это понятие подробнее, особенно в контексте вашего примера с шаблонами и указателями.

---

## 1. Что такое CV-квалификаторы?
- В C++ есть два CV-квалификатора:
  - `const`: Указывает, что объект или его часть нельзя изменять.
  - `volatile`: Указывает, что значение объекта может изменяться внешними факторами (например, аппаратным обеспечением), и компилятор не должен оптимизировать доступ к нему.
- Эти квалификаторы могут применяться к различным уровням типа, особенно в сложных типах, таких как указатели или ссылки.

---

### 2. Что такое "внешний" CV-квалификатор?
- **Внешний (или верхний, top-level) CV-квалификатор** — это `const` или `volatile`, который относится к самому объекту или переменной, а не к данным, на которые он указывает или ссылается.
- Это важно различать в типах, которые имеют несколько уровней, например, указатели или указатели на указатели.

#### Пример:
Рассмотрим переменную `z` из вашего кода:
```cpp
int const * const z = &x;
```
- Тип `z` — `int const * const`.
- Разберём его:
  - `int const *`: Первый уровень — это указатель на `const int`. Здесь `const` относится к данным, на которые указывает `z` (т.е. `*z` нельзя изменить). Этот `const` — **не внешний**, а внутренний, потому что он относится к данным, а не к самому указателю.
  - `const z`: Второй `const` относится к самому указателю `z`. Это значит, что сам `z` (адрес, который он хранит) нельзя изменить. Этот `const` — **внешний CV-квалификатор**, потому что он применяется к верхнему уровню типа `z` (к самому указателю).

#### Другой пример:
```cpp
const int x = 42;
```
- Здесь `const` — это внешний CV-квалификатор, потому что он применяется непосредственно к `x` (верхний уровень типа `int`).

#### Ещё пример:
```cpp
int * const p = &some_int;
```
- Тип `p` — `int * const`.
- Здесь `const` — внешний CV-квалификатор, потому что он относится к самому указателю `p`, а не к данным, на которые он указывает (`int *`).

---

### 3. Почему "внешний" CV-квалификатор важен в вашем коде?

В вашем примере с шаблонами:
```cpp
template <typename T> void foo(T t);
template <typename T> void bar(T& t);

int x = 42;
int const &y = x;
int const * const z = &x;

foo(z); // -> foo<int const *>(int const *)
bar(z); // -> bar<int const * const>(int const * const &)
```

#### Поведение в `foo` (передача по значению):
- В функции `foo` параметр `t` передаётся **по значению**, то есть создаётся копия аргумента.
- Когда компилятор выводит тип `T`, он **игнорирует внешние CV-квалификаторы** аргумента, потому что копия внутри функции — это новая локальная переменная, и её "константность" (или "волатильность") не имеет значения.
- Для `z` (тип `int const * const`):
  - Внешний CV-квалификатор — это второй `const` (относящийся к самому указателю `z`).
  - Этот `const` снимается при передаче по значению, так как копия указателя внутри `foo` не обязана быть `const`.
  - Однако первый `const` (в `int const *`) остаётся, потому что он относится к данным, на которые указывает указатель, а не к самому указателю (это не внешний квалификатор).
- Итог: `T` выводится как `int const *`, и вызов становится `foo<int const *>(int const *)`.

#### Поведение в `bar` (передача по ссылке):
- В функции `bar` параметр `t` передаётся **по ссылке**, то есть `T&` привязывается к исходному объекту.
- При передаче по ссылке внешние CV-квалификаторы **не снимаются**, потому что `bar` работает с самим объектом, а не с его копией.
- Для `z` (тип `int const * const`):
  - Внешний CV-квалификатор (`const` для самого указателя) сохраняется, так как `bar` принимает `z` по ссылке.
  - `T` выводится как `int const * const`, чтобы `T&` соответствовало `int const * const &`.
- Итог: вызов становится `bar<int const * const>(int const * const &)`.

---

### 4. Почему внешние CV-квалификаторы снимаются при передаче по значению?
- Когда аргумент передаётся по значению, создаётся копия объекта. Копия — это новая локальная переменная, и её "константность" (или "волатильность") не влияет на исходный объект.
- Например:
  ```cpp
  const int x = 42;
  foo(x); // -> foo<int>(int)
  ```
  - Тип `x` — `const int`.
  - Внешний CV-квалификатор — это `const`.
  - При передаче по значению `const` снимается, и `T` становится `int`.

- Но если у нас сложный тип, например, указатель:
  ```cpp
  int const * const z = &x;
  foo(z); // -> foo<int const *>(int const *)
  ```
  - Внешний CV-квалификатор (`const` для самого `z`) снимается.
  - Но `const` в `int const *` (относящийся к данным) остаётся, так как он не внешний, а вложенный.

---

### 5. Почему внешние CV-квалификаторы сохраняются при передаче по ссылке?
- При передаче по ссылке (`T&`) функция работает с исходным объектом, а не с его копией.
- Компилятор должен учитывать все квалификаторы, включая внешние, чтобы сохранить семантику объекта.
- Например:
  ```cpp
  bar(z); // -> bar<int const * const>(int const * const &)
  ```
  - Тип `z` — `int const * const`.
  - Внешний CV-квалификатор (`const` для указателя) сохраняется, так как `bar` принимает `z` по ссылке.

---

### 6. Итог:
- **Внешний CV-квалификатор** — это `const` или `volatile`, относящийся к верхнему уровню типа (например, к самому объекту или указателю, а не к данным, на которые он указывает).
- При **передаче по значению** внешние CV-квалификаторы снимаются, так как создаётся копия, и её "константность" не важна.
- При **передаче по ссылке** внешние CV-квалификаторы сохраняются, так как функция работает с исходным объектом.
- В вашем примере:
  - Для `z` (тип `int const * const`) внешний CV-квалификатор — это второй `const`.
  - В `foo` он снимается → `T = int const *`.
  - В `bar` он сохраняется → `T = int const * const`.


## Еще один пример 
```c++
template <typename T> void foo(T t);
template <typename T> void buz(T* t);

int x = 42;
int *px = &x;
int *& py = px;
int const * const pz = px;

foo(px); // -> foo<int*>(int*)
foo(py); // -> foo<int*>(int*)
foo(pz); // -> foo<int const *>(int const *)

buz(px); // -> buz<int>(int**)
buz(py); // -> buz<int>(int**)
buz(pz); // -> buz<int const>(int const * const)
```

## И еще одна задачка для закрепления

```c++
template <typename T> void foo(T * const & t);

int x = 42;
int const &y = x;
int const *z = &x;

foo(&x); // -> foo<int>(int * const &)
foo(&y); // -> foo<int const>(int const * const &)
foo(z);  // -> foo<int const>(int const * const &)
```

# Хинты для вывода типов

как заставить код работать:

```c++
template<typename T> struct container
{
    template<typename Iter>
    container(Iter beg, Iter end); // e.t.c
}

vector<double> v;
auto d = cocntainer(v.begin(), v.end()) // -> container<double>? 
```

Сейчас это приведет к ошибке вывода типов. 

А вот как решить эту проблему: 

```c++
template<class Iter> container(Iter b, Iter e) ->
    container<typename iterator_traits<Iter>::value_type>;
```

И в таком случае вывод произойдет и будет корректен. 

## Что делать, если выводить хочется для структур без конструкторов

```c++
template<typename T>
struct NamedValue
{
    T value;
    string name;
};

NamedValue(const char*, const char*) -> NamedValue<string>;

NamedValue n{"hello", "world"};
```

# auto and decltype

Такой же гибкости для вывода типов хотелось для локальных типов и ввели `auto`

`auto x = query_resource(0); //` 

## Правило для auto 

Ключевое слово auto выводит типы так же как шаблон функции с тем же
правилом для уточнения типов

```c++
const int x = 42;
auto y = x; // -> int y = x;
auto &z = x; // -> const int &z = x;
```

Важно, уточнение cv-квалификаторов (относительно тому
по указателю) неудаляют никогда.

```c++
int const *const x = 42;
auto y = x; // -> int const *y = x;
auto *z = x; // -> int const *const z = x;
```

### Дополнительные правила

Тип заменяет во всех вхождениях контекста

```c++
auto x = new auto('a'); // -> char *x = new char('a');
```

Для auto замена на тип

```c++
auto x = 1, y = 1.6; // fail
```

Начиная с C++17 можно на полях вывести braced-инициализатора

```c++
auto x(1); // -> int x(1);
```

Но это только для конструктора

```c++
auto x = {1}; // -> std::initializer_list<int> x = {1};
```

## decltype 

При использовании `auto` может прозойти нежелательная срезка типов, поэтому, если мы хотим точно тот тип, который указан, то нам нужно указать это при помощи  `decltype`

```c++
int foo(const float& x)
{
    decltype(x) tmp = 0.0f; // ok, и значит ровно то, что нужно 
}
```

### Но есть нюансы

```c++
struct Point { int x, y; };

Point porig {1, 2};
const Point &p = porig;
```

Случай decltype(id-expr)

```c++
decltype(p.x) x = 0; // -> int x = 0;
```

Случай decltype(expr)

```c++
decltype((p.x)) x = 0; // -> const int &x = 0;
```

Важный corner-case: если в decltype(expr) окажется, что expr это lvalue,
то decltype(expr) добавляет lvalue reference к выведенному типу

```c++
decltype((porig)) x = porig; // -> Point &x = porig;
```

Но почему он добавляет эту ссылку? 

Рассмотрим пример с массивом:

```c++
int x[10];
x[5] = 4; // здесть x[5] работает как ссылка
decltype(x[5]) y = x[5]; // -> int& y = x[5];
y = 4; // изменит x[5]
```

>Эта особенность еще найдет свое полезное применение

## Пупупуууу... decltype(auto)

```c++
double x = 1.0;
decltype(x) tmp = x;
decltype(auto) tmp = x;
```

Однкако что стоит справа expr or id-expr Зависиит от выражения...

```c++
decltype(auto) tmp = x;   // double tmp = x;
decltype(auto) tmp = (x); // double& tmp = x;
```


## Проблема и ее странное решение

```c++
template<typename T>
auto // c++11 FAIL
makeAndProcessObject(const T& builder)
{
    auto val = builder.makeObject();
    ...
    return val;
}
```

Но есть сомнительное решение:

```c++
template<typename T>
decltype(((T*)(0))->makeObject()) // Pain
makeAndProcessObject(const T& builder)
{
    auto val = builder.makeObject();
    ...
    return val;
}
```

Но есть решение более элегантное

```c++
template<typename T>
auto makeAndProcessObject(const T& builder) -> decltype(builder.makeObject())
{
    auto val = builder.makeObject();
    ...
    return val;
}
```

Но проблема с гетерогенным максимумом осталась

```c++
template<typename T, typename S>
auto max(T x,S y) -> decltype(x < y ? x : y>)
{
    return x < y ? x : y;
}
```

Но тернарный оператор является lvalue reference, поэтому если T == S = int То вернется int& и у нас вернется ссылка на временный объект. 

И начиная с С++14 можно решить проблему гетерогенного минимума 

```c++
template<typename T, typename S>
auto max(T x,S y)
{
    return x < y ? x : y;
}
```

Но иногда это сбивается:

```c++
auto bad_sum_to(int i)
{
    return (i > 2) ? bad_sum_to(i-1) + i : i;
}
```

Получим use before deduction. Так же будет для forward declaration. 

### Один забавный рекурсинвый пазл 

Из книги More Exceptional C++ Герба Саттера. 

```c++
??? foo() { cout << "Foo" << endl; return foo; }
auto f = foo(); // Foo
f(); // Foo
```

Вопрос в том, как записать ее возвращаемый тип? 


# Более тонкая работа с типами 

Так `auto`  режет типы, но проблему можно решить при помощи `decltype(auto)`

```c++
string lookup1();
string& lookup2();

auto do1() { return lookup1(); } // string do1()
auto do2() { return lookup2(); } // string do2()

decltype(auto) do1() { return lookup1(); } // string do1()
decltype(auto) do2() { return lookup2(); } // string& do2()
```

## Проблема. Прозрачная оболочка. 

```c++
template<typenmae Fun, typename Arg>
decltype(auto) callme(Fun fun, Arg arg)
{
    return fun(arg);
}
```

У решения есть проблемы:

- Передаем только 1 аргумент 
- Аргумент копируется 
- Квалификаторы режутся и все работает как-то не прозрачно

## Контрольный вопрос

```c++
??? lookupValue(int idx)
{
    auto ind = calcValue(idx);
    auto val = values[idx]; // int
    return (val); // int&
}
```

если написать `decltype(auto)` то получим висячую ссылку. 


# Как посмотреть выводимые типы при инстанцировации шаблонных парамеров

1. Ошибка компиляции 
2. Ошибка линкера
3. Через boost typeinfo
4. Через переходник типов и tipeid<>.name()

